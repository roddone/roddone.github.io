<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>roddone.github.io</title>
    <link href="https://roddone.github.io/feed.xml" rel="self" />
    <link href="https://roddone.github.io" />
    <updated>2018-10-09T16:18:03+02:00</updated>
    <author>
        <name>Romain ODDONE</name>
    </author>
    <id>https://roddone.github.io</id>

    <entry>
        <title>Accéder à son planning de sérievore avec Betaseries.Net</title>
        <author>
            <name>Romain ODDONE</name>
        </author>
        <link href="https://roddone.github.io/acceder-a-son-planning-de-serie-vore-avec-betaseriesnet/"/>
        <id>https://roddone.github.io/acceder-a-son-planning-de-serie-vore-avec-betaseriesnet/</id>
            <category term="library"/>
            <category term="c#"/>
            <category term="betaseries"/>
            <category term=".net"/>

        <updated>2018-10-09T15:31:09+02:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://roddone.github.io/media/posts/3/betaseries_1980.png" alt="" />
                    Betaseries est un service en ligne permettant de suivre ses séries préférées et d'être prévenu dès qu'une nouvelle saison ou un nouvel épisode est sorti. Comme tout bon service qui se respecte, il met à disposition une API REST qui permet de faire tout ce que&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <img src="https://roddone.github.io/media/posts/3/betaseries_1980.png" alt="" />
                <p><a href="https://www.betaseries.com/" target="_blank" rel="noopener noreferrer">Betaseries </a>est un service en ligne permettant de suivre ses séries préférées et d'être prévenu dès qu'une nouvelle saison ou un nouvel épisode est sorti.</p>
<p>Comme tout bon service qui se respecte, il met à disposition une <a href="https://www.betaseries.com/api/" target="_blank" rel="noopener noreferrer">API REST</a> qui permet de faire tout ce que fait le site officiel. Il existe des applications pour à peu près toutes les plateformes mais je n'ai pas trouvé de librairie permettant d'utiliser cette API en C# dans mes applications.</p>
<p>J'ai donc décidé de commencer cette implémentation mais j'ai vite déchanté en voyant la quantité d'entités REST à implémenter. En effet j'avais juste besoin de récupérer mon planning, mais je n'avais pas le temps d'implémenter une API aussi conséquente. Comme je n'avais pas non plus envie de livrer une API incomplète, j'ai donc cherché un moyen pour tout implémenter de façon générique afin que l'API soit entièrement utilisable, quitte à repasser sur les entités par la suite pour implémenter leur description.</p>
<p>Toutes les entités sont du type : &lt;Entité&gt;/&lt;Action&gt;.J'ai donc créé toutes les classes décrivant les entités REST, puis pour chaque entité des classes imbriquées que j'ai doté par héritage de méthodes GET|POST|PUT|DELETE retournant un type dynamic. De cette façon toutes les entités BetaSeries existent et sont appelables sans pour autant être entièrement décrites.</p>
<p>Par exemple, pour manipuler ses séries on n'a plus qu'à appeler :</p>
<pre><span class="pl-smi">SHOWS</span>.<span class="pl-smi">Display</span>.[<span class="pl-smi">Delete</span><span class="pl-k">|</span><span class="pl-smi">Get</span><span class="pl-k">|</span><span class="pl-smi">Post</span><span class="pl-k">|</span><span class="pl-smi">Put</span>]();</pre>
<p>Le projet est sur <a href="https://github.com/roddone/BetaSeries.Net" target="_blank" rel="noopener noreferrer">github </a>et n'attend que vos pull-requests pour évoluer ;)</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Contrôler ses ampoules Yeelight en C#</title>
        <author>
            <name>Romain ODDONE</name>
        </author>
        <link href="https://roddone.github.io/controler-ses-ampoules-yeelight-en-c/"/>
        <id>https://roddone.github.io/controler-ses-ampoules-yeelight-en-c/</id>
            <category term="yeelight"/>
            <category term="xiaomi"/>
            <category term="library"/>
            <category term="iot"/>
            <category term="c#"/>
            <category term="bulb"/>
            <category term=".net"/>

        <updated>2018-10-09T14:21:36+02:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://roddone.github.io/media/posts/1/ifttt2.png" alt="" />
                    Yeelight est la solution de luminaires connectés de Xiaomi. Contrairement aux périphériques Phillips Hue, celles-ci sont directement connectées en Wi-fi et ne nécessitent pas de pont pour les connecter. Ce système a ses avantages et inconvénients mais permet de débuter dans le monde des objets connectés&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <img src="https://roddone.github.io/media/posts/1/ifttt2.png" alt="" />
                <p>Yeelight est la solution de luminaires connectés de Xiaomi. Contrairement aux périphériques Phillips Hue, celles-ci sont directement connectées en Wi-fi et ne nécessitent pas de pont pour les connecter. </p>
<p>Ce système a ses avantages et inconvénients mais permet de débuter dans le monde des objets connectés à faible coût (compter environ 20€ pour une ampoule couleur).</p>
<p>Ce qui nous intéresse ici est surtout de les contrôler via une API, c'est ce que je me suis efforcé de faire dans <a href="http://github.com/roddone/YeelightAPI" title="Lien vers le github de YeelightAPI" target="_blank" rel="noopener noreferrer">YeelightAPI</a>. Dans sa grande bonté, Yeelight met à disposition des développeurs une <a href="https://www.yeelight.com/download/Yeelight_Inter-Operation_Spec.pdf" title="Lien vers la documentation officielle Yeelight" target="_blank" rel="noopener noreferrer">documentation </a>technique expliquant leur protocole et les différentes méthodes disponibles. Les deux principales fonctionnalités étant la découverte de périphériques et leur contrôle, j'ai pu les implémenter grâce à cette documentation.</p>
<p>La découverte des périphériques se base sur le protocole SSDP (UDP) et permet non seulement de récupérer les périphériques sur le réseau (modèle, hostname, version de firmware) mais également leurs capacités (changement de couleur, luminosité, température etc.).</p>
<p>Le contrôle se fait par des requêtes TCP dont la requête au format JSON contient le nom de la méthode à appeler ainsi que les différents paramètres. On peut ainsi allumer/éteindre, changer la couleur/luminosité/température, démarrer des scènes etc. Les appels sont ensuite automatiquement suivis d'une réponse du device (toujours en JSON) indiquant simplement "ok" en cas de succès, ou un code + message d'erreur si la requête a échoué.</p>
<p>Autre chose assez pratique pour suivre l'état d'un Device : dès qu'une action est faîte sur un device, celui-ci envoi une notification indiquant la propriété ayant changé ainsi que sa nouvelle valeur.</p>
<p>Pour simplifier tout cela, j'ai conçu <a href="http://github.com/roddone/YeelightAPI" title="Lien vers le github de YeelightAPI">YeelightAPI</a> comme un wrapper autour des différentes méthodes afin de simplifier leur appel.</p>
<p>Pour cela rien deplus simple, la classe <code>DeviceLocator</code> permet de lancer une recherche des périphériques sur le réseau. Ces périphériques sont des objets de type <code>Device</code> et possèdent toutes les méthodes possibles. Un objet <code>DeviceGroup</code> permet de contrôler plusieurs Devices en même temps. Pour finir, toute l'API est basée sur le système d'async/await de C#. La documentation complète se trouve sur <a href="http://github.com/roddone/YeelightAPI" title="Lien vers le github de YeelightAPI">github</a>.</p>
            ]]>
        </content>
    </entry>
</feed>
