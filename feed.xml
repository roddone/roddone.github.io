<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Romain ODDONE</title>
    <link href="https://blog.roddone.ovh/feed.xml" rel="self" />
    <link href="https://blog.roddone.ovh" />
    <updated>2019-05-03T17:36:55+02:00</updated>
    <author>
        <name>Romain ODDONE</name>
    </author>
    <id>https://blog.roddone.ovh</id>

    <entry>
        <title>Skill Alexa &quot;Mon Planning Séries&quot;</title>
        <author>
            <name>Romain ODDONE</name>
        </author>
        <link href="https://blog.roddone.ovh/skill-alexa-mon-planning-series/"/>
        <id>https://blog.roddone.ovh/skill-alexa-mon-planning-series/</id>

        <updated>2019-05-03T17:20:15+02:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://blog.roddone.ovh/media/posts/6/alexa-portrait.png" alt="" />
                    Amazon propose très régulièrement aux développeurs des défis permettant de promouvoir leur assistant vocal Alexa. Le principe est souvent de publier une skill sur leur store pour en échange gagner un appareil Alexa. Etant déjà un utilisateur d'Alexa et ayant envie de gagner un nouvel&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <img src="https://blog.roddone.ovh/media/posts/6/alexa-portrait.png" alt="" />
                <p>Amazon propose très régulièrement aux développeurs des défis permettant de promouvoir leur assistant vocal Alexa. Le principe est souvent de publier une skill sur leur store pour en échange gagner un appareil Alexa.</p>
<p>Etant déjà un utilisateur d'Alexa et ayant envie de gagner un nouvel Echo Dot, je me suis lancé dans la création d'une skill permettant de récupérer via Alexa le planning de mes sorties séries via l'API BetaSeries <a href="#INTERNAL_LINK#/post/3">que j'ai déjà eu l'occasion de manipuler</a>.<br>L'utilisation est très simple et fait à la voix : <em>"Alexa, demande à mon planning séries les épisodes de <strong>demain</strong> | <strong>aujourd'hui</strong> | <strong>Jeudi</strong>"</em> ou encore plus simplement : <em>"Alexa, demande à mon planning séries<strong> les nouveautés</strong>".</em></p>
<p>J'ai choisi pour cela de développer la skill via Node.JS et de l'héberger moi-même sur Amazon AWS pour mieux comprendre les subtilités de l'écosystème Amazon.<br>Pour aller plus loin dans les technologies utilisées, j'utilise les webservices BetaSeries pour la récupération du planning d'un utilisateur, couplé à leur provider d'authentification OAuth permettant aux utilisateurs Alexa de lier leur skill à leur compte BetaSeries.<br>Le développement en JavaScript natif ne proposant pas d'auto-complétion dans l'éditeur, j'ai migré en cours de route sur TypeScript pour plus de confort lors du développement et plus de facilité à utiliser l'API Alexa.<br>Pour finir, j'ai automatisé le déploiement de la skill sur AWS en utilisant un pipeline de build Azure Devops pour le build du projet (npm install + npm run build) et le déploiement sur AWS via AWS CLI.</p>
<p>Pour les curieux qui possèdent Alexa, la skill est disponible directement sur <a href="https://www.amazon.fr/Romain-ODDONE-Mon-planning-s%C3%A9ries/dp/B07N8WH5M9" target="_blank" rel="noopener noreferrer">le store Amazon</a>, Enjoy ;)</p>
<p>PS : j'ai gagné l'Echo Dot </p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Société Dunkerquoise d&#x27;Histoire et d&#x27;Archéologie</title>
        <author>
            <name>Romain ODDONE</name>
        </author>
        <link href="https://blog.roddone.ovh/societe-dunkerquoise-dhistoire-et-darcheologie/"/>
        <id>https://blog.roddone.ovh/societe-dunkerquoise-dhistoire-et-darcheologie/</id>

        <updated>2019-05-03T17:28:14+02:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://blog.roddone.ovh/media/posts/5/cropped-DK15831.png" alt="" />
                    Le site internet de la Société Dunkerquoise d'Histoire et d'Archéologie ayant besoin d'un coup de jeune, l'association m'a solicité pour le remettre au gout du jour. https://sdha.fr Site réalisé avec Wordpress.
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <img src="https://blog.roddone.ovh/media/posts/5/cropped-DK15831.png" alt="" />
                <p>Le site internet de la Société Dunkerquoise d'Histoire et d'Archéologie ayant besoin d'un coup de jeune, l'association m'a solicité pour le remettre au gout du jour.</p>
<p><a href="https://sdha.fr" target="_blank" rel="noopener noreferrer" title="site internet de la Société Dunkerquoise d'Histoire et d'Archéologie">https://sdha.fr</a></p>
<p> </p>
<p>Site réalisé avec Wordpress.</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Gérer ses temps de chargements Ajax avec Angular JS 1.x</title>
        <author>
            <name>Romain ODDONE</name>
        </author>
        <link href="https://blog.roddone.ovh/gerer-ses-chargements-avec-angular-js-1x/"/>
        <id>https://blog.roddone.ovh/gerer-ses-chargements-avec-angular-js-1x/</id>

        <updated>2019-05-03T17:28:20+02:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://blog.roddone.ovh/media/posts/4/800px-AngularJS_logo.svg1.png" alt="" />
                    Quand on fait du développement web, il arrive forcément un moment où les temps de réponse de web-services peuvent gacher l'affichage d'une page. Pour éviter cela on a la solution de mettre un bon vieux loader à l'endroit où nos données ne sont pas encore&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <img src="https://blog.roddone.ovh/media/posts/4/800px-AngularJS_logo.svg1.png" alt="" />
                <p>Quand on fait du développement web, il arrive forcément un moment où les temps de réponse de web-services peuvent gacher l'affichage d'une page. Pour éviter cela on a la solution de mettre un bon vieux loader à l'endroit où nos données ne sont pas encore affichées.</p>
<p>En angular c'est simple, on n'a qu'à utiliser un booléen dans le scope de son controller, et en fonction de sa valeur afficher le contenu ou le template "chargement en cours ...".<br>L'inconvénient est que sur une page cela peut donner lieu à une multitude de variables différentes dans la partie JavaScript, et donc de &lt;div ng-if &gt; dans le html et ainsi vite devenir illisible. Comme dans 90% des cas on doit afficher un loader lors d'une requête Ajax, pourquoi ne pas utiliser directement la Promise Angular à la place d'un booléen ? On peut ainsi facilement créer un composant angular qui prend en paramètre la promesse et affichera le loader tant que la promesse n'a pas été résolue. On peut aller encore plus loin et afficher un autre message si la promesse a renvoyé une erreur !</p>
<p>exemple : </p>
<pre>&lt;<span class="pl-ent">loading</span> <span class="pl-e">trigger</span>=<span class="pl-s"><span class="pl-pds">"</span>myHttpTrigger<span class="pl-pds">"</span></span>&gt;
         &lt;<span class="pl-ent">content</span>&gt; Loaded ! &lt;/<span class="pl-ent">content</span>&gt;
         &lt;<span class="pl-ent">loader</span>&gt; Loading ... &lt;/<span class="pl-ent">loader</span>&gt;
         &lt;<span class="pl-ent">error</span>&gt;
             An error ocurred :( 
         &lt;/<span class="pl-ent">error</span>&gt;
 &lt;/<span class="pl-ent">loading</span>&gt;</pre>
<p>Ici le paramètre "trigger" est le paramètre d'entrée de type HttpPromise, mais on peut aussi lui passer un booléen pour les cas où on attend autre chose que la fin d'exécution d'une requête Ajax, ou bien une Promise JavaScript classique.</p>
<p>Le code complet est sur <a href="https://github.com/roddone/ng-loading-placeholder" target="_blank" rel="noopener noreferrer">Github</a>, have fun ;)</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Accéder à son planning de sérievore avec Betaseries.Net</title>
        <author>
            <name>Romain ODDONE</name>
        </author>
        <link href="https://blog.roddone.ovh/acceder-a-son-planning-de-serie-vore-avec-betaseriesnet/"/>
        <id>https://blog.roddone.ovh/acceder-a-son-planning-de-serie-vore-avec-betaseriesnet/</id>

        <updated>2018-10-09T15:31:09+02:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://blog.roddone.ovh/media/posts/3/betaseries_1980.png" alt="" />
                    Betaseries est un service en ligne permettant de suivre ses séries préférées et d'être prévenu dès qu'une nouvelle saison ou un nouvel épisode est sorti. Comme tout bon service qui se respecte, il met à disposition une API REST qui permet de faire tout ce que&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <img src="https://blog.roddone.ovh/media/posts/3/betaseries_1980.png" alt="" />
                <p><a href="https://www.betaseries.com/" target="_blank" rel="noopener noreferrer">Betaseries </a>est un service en ligne permettant de suivre ses séries préférées et d'être prévenu dès qu'une nouvelle saison ou un nouvel épisode est sorti.</p>
<p>Comme tout bon service qui se respecte, il met à disposition une <a href="https://www.betaseries.com/api/" target="_blank" rel="noopener noreferrer">API REST</a> qui permet de faire tout ce que fait le site officiel. Il existe des applications pour à peu près toutes les plateformes mais je n'ai pas trouvé de librairie permettant d'utiliser cette API en C# dans mes applications.</p>
<p>J'ai donc décidé de commencer cette implémentation mais j'ai vite déchanté en voyant la quantité d'entités REST à implémenter. En effet j'avais juste besoin de récupérer mon planning, mais je n'avais pas le temps d'implémenter une API aussi conséquente. Comme je n'avais pas non plus envie de livrer une API incomplète, j'ai donc cherché un moyen pour tout implémenter de façon générique afin que l'API soit entièrement utilisable, quitte à repasser sur les entités par la suite pour implémenter leur description.</p>
<p>Toutes les entités sont du type : &lt;Entité&gt;/&lt;Action&gt;.J'ai donc créé toutes les classes décrivant les entités REST, puis pour chaque entité des classes imbriquées que j'ai doté par héritage de méthodes GET|POST|PUT|DELETE retournant un type dynamic. De cette façon toutes les entités BetaSeries existent et sont appelables sans pour autant être entièrement décrites.</p>
<p>Par exemple, pour manipuler ses séries on n'a plus qu'à appeler :</p>
<pre><span class="pl-smi">SHOWS</span>.<span class="pl-smi">Display</span>.[<span class="pl-smi">Delete</span><span class="pl-k">|</span><span class="pl-smi">Get</span><span class="pl-k">|</span><span class="pl-smi">Post</span><span class="pl-k">|</span><span class="pl-smi">Put</span>]();</pre>
<p>Le projet est sur <a href="https://github.com/roddone/BetaSeries.Net" target="_blank" rel="noopener noreferrer">github </a>et n'attend que vos pull-requests pour évoluer ;)</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Contrôler ses ampoules Yeelight en C#</title>
        <author>
            <name>Romain ODDONE</name>
        </author>
        <link href="https://blog.roddone.ovh/controler-ses-ampoules-yeelight-en-c/"/>
        <id>https://blog.roddone.ovh/controler-ses-ampoules-yeelight-en-c/</id>

        <updated>2018-10-09T14:21:36+02:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://blog.roddone.ovh/media/posts/1/ifttt2.png" alt="" />
                    Yeelight est la solution de luminaires connectés de Xiaomi. Contrairement aux périphériques Phillips Hue, celles-ci sont directement connectées en Wi-fi et ne nécessitent pas de pont pour les connecter. Ce système a ses avantages et inconvénients mais permet de débuter dans le monde des objets connectés&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <img src="https://blog.roddone.ovh/media/posts/1/ifttt2.png" alt="" />
                <p>Yeelight est la solution de luminaires connectés de Xiaomi. Contrairement aux périphériques Phillips Hue, celles-ci sont directement connectées en Wi-fi et ne nécessitent pas de pont pour les connecter. </p>
<p>Ce système a ses avantages et inconvénients mais permet de débuter dans le monde des objets connectés à faible coût (compter environ 20€ pour une ampoule couleur).</p>
<p>Ce qui nous intéresse ici est surtout de les contrôler via une API, c'est ce que je me suis efforcé de faire dans <a href="http://github.com/roddone/YeelightAPI" title="Lien vers le github de YeelightAPI" target="_blank" rel="noopener noreferrer">YeelightAPI</a>. Dans sa grande bonté, Yeelight met à disposition des développeurs une <a href="https://www.yeelight.com/download/Yeelight_Inter-Operation_Spec.pdf" title="Lien vers la documentation officielle Yeelight" target="_blank" rel="noopener noreferrer">documentation </a>technique expliquant leur protocole et les différentes méthodes disponibles. Les deux principales fonctionnalités étant la découverte de périphériques et leur contrôle, j'ai pu les implémenter grâce à cette documentation.</p>
<p>La découverte des périphériques se base sur le protocole SSDP (UDP) et permet non seulement de récupérer les périphériques sur le réseau (modèle, hostname, version de firmware) mais également leurs capacités (changement de couleur, luminosité, température etc.).</p>
<p>Le contrôle se fait par des requêtes TCP dont la requête au format JSON contient le nom de la méthode à appeler ainsi que les différents paramètres. On peut ainsi allumer/éteindre, changer la couleur/luminosité/température, démarrer des scènes etc. Les appels sont ensuite automatiquement suivis d'une réponse du device (toujours en JSON) indiquant simplement "ok" en cas de succès, ou un code + message d'erreur si la requête a échoué.</p>
<p>Autre chose assez pratique pour suivre l'état d'un Device : dès qu'une action est faîte sur un device, celui-ci envoi une notification indiquant la propriété ayant changé ainsi que sa nouvelle valeur.</p>
<p>Pour simplifier tout cela, j'ai conçu <a href="http://github.com/roddone/YeelightAPI" title="Lien vers le github de YeelightAPI">YeelightAPI</a> comme un wrapper autour des différentes méthodes afin de simplifier leur appel.</p>
<p>Pour cela rien deplus simple, la classe <code>DeviceLocator</code> permet de lancer une recherche des périphériques sur le réseau. Ces périphériques sont des objets de type <code>Device</code> et possèdent toutes les méthodes possibles. Un objet <code>DeviceGroup</code> permet de contrôler plusieurs Devices en même temps. Pour finir, toute l'API est basée sur le système d'async/await de C#. La documentation complète se trouve sur <a href="http://github.com/roddone/YeelightAPI" title="Lien vers le github de YeelightAPI">github</a>.</p>
            ]]>
        </content>
    </entry>
</feed>
